"""
Backtest module
Use backtrader to implement backtest functionality
"""

import backtrader as bt
from langchain.agents import tool
#Is it langchain.chat_models (or) langchain_openai ??
from langchain.chat_models import ChatOpenAI
import pandas as pd
import numpy as np
from typing import List, Dict, Any, Union
from datetime import datetime
from utils.logger import setup_logger
from config.settings import (
    INITIAL_CAPITAL,
    COMMISSION_RATE
)
from core.tools.indicators_process import get_historical_data, calculate_indicators
import json

logger = setup_logger(__name__)

class BacktestEngine:
    def __init__(self):
        """Initialize backtest engine"""
        self.cerebro = bt.Cerebro()
        self.cerebro.broker.setcash(INITIAL_CAPITAL)
        self.cerebro.broker.setcommission(commission=COMMISSION_RATE)
        self.cerebro.addsizer(bt.sizers.PercentSizer, percents=10)  # 10% of position per trade
        self.strategy_config = None
        
        # Add analyzers
        self.cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe')
        self.cerebro.addanalyzer(bt.analyzers.DrawDown, _name='drawdown')
        self.cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name='trades')
        self.cerebro.addanalyzer(bt.analyzers.Returns, _name='returns')

    def set_data(self, data: pd.DataFrame) -> None:
        """
        Set backtest data
        
        Args:
            data: DataFrame containing historical prices and technical indicators
        """
        if data is None or len(data) == 0:
            logger.error("No data provided for backtest")
            raise ValueError("No data provided for backtest")
            
        # 确保列名小写
        data = data.copy()
        data.columns = [col.lower() for col in data.columns]
            
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        if not all(col in data.columns for col in required_columns):
            logger.error(f"Missing required columns. Required: {required_columns}, Got: {data.columns.tolist()}")
            raise ValueError("Backtest data must contain OHLCV data")
            
        logger.info(f"Data length before processing: {len(data)}")
        logger.info(f"Data columns: {data.columns.tolist()}")
        logger.info(f"Data first row: {data.iloc[0].to_dict() if len(data) > 0 else 'No data'}")
        
        # 确保datetime列的数据类型正确
        if 'datetime' in data.columns:
            data['datetime'] = pd.to_datetime(data['datetime'])
        
        # 确保数值列的数据类型正确
        for col in ['open', 'high', 'low', 'close', 'volume']:
            data[col] = pd.to_numeric(data[col], errors='coerce')
        
        # 检查空值
        null_counts = data[required_columns].isnull().sum()
        if null_counts.any():
            logger.error(f"Data contains null values: {null_counts[null_counts > 0].to_dict()}")
            raise ValueError("Data contains null values")
        
        # 创建数据源
        data_feed = bt.feeds.PandasData(
            dataname=data,
            datetime='datetime',
            open='open',
            high='high',
            low='low',
            close='close',
            volume='volume',
            openinterest=-1
        )
        
        # 添加数据到回测引擎
        logger.info("Adding data to backtest engine")
        self.cerebro.adddata(data_feed)
        
        # 验证数据是否成功添加
        if not self.cerebro.datas:
            logger.error("No data added to backtest engine")
            raise ValueError("Failed to add data to backtest engine")
        
        logger.info(f"Data successfully added to backtest engine")
        logger.info(f"Number of data feeds: {len(self.cerebro.datas)}")

    def add_strategy(self, strategy_config: Dict[str, Any]) -> None:
        """
        Add strategy
        
        Args:
            strategy_config: Strategy configuration dictionary, generated by generate_strategies
        """
        logger.info(f"Adding strategy: {strategy_config.get('name', 'Unnamed Strategy')}")
        logger.debug(f"Strategy configuration: {json.dumps(strategy_config, indent=2, ensure_ascii=False)}")
        
        # 处理规则格式
        if isinstance(strategy_config['rule'], str):
            # 如果是字符串格式，转换为列表格式
            strategy_config['rule'] = [
                {
                    "type": "entry",
                    "expr": strategy_config['rule']
                },
                {
                    "type": "exit",
                    "expr": strategy_config['rule'].replace('>', '<').replace('CrossOver(A, B) > 0', 'CrossOver(A, B) < 0')
                }
            ]
        
        self.strategy_config = strategy_config
        
        # Create strategy class
        class Strategy(bt.Strategy):
            def __init__(self):
                super().__init__()
                self.warmup_period = 0
                self.previous_values = {}  # 存储前一个周期的值
                self.manual_indicators = {}  # 存储手动计算的指标值
                logger.info("Strategy initialized - using manual indicators only")
                
            def calculate_manual_crossover(self, current_value, reference_value, prev_current, prev_reference):
                """
                手动计算交叉信号
                返回: 1 (向上交叉), -1 (向下交叉), 0 (无交叉)
                """
                if prev_current is None or prev_reference is None:
                    return 0.0
                
                # 向上交叉：当前值 > 参考值 且 前一个值 <= 前一个参考值
                if current_value > reference_value and prev_current <= prev_reference:
                    return 1.0
                # 向下交叉：当前值 < 参考值 且 前一个值 >= 前一个参考值  
                elif current_value < reference_value and prev_current >= prev_reference:
                    return -1.0
                else:
                    return 0.0
                    
            def calculate_sma(self, period):
                """计算SMA"""
                try:
                    if len(self.data) >= period:
                        prices = [self.data.close[-i] for i in range(period)]
                        return sum(prices) / len(prices)
                    return 0.0
                except:
                    return 0.0
                    
            def calculate_ema(self, period):
                """计算EMA"""
                try:
                    if len(self.data) >= period:
                        key = f'EMA_{period}_prev'
                        if key not in self.manual_indicators:
                            # 初始EMA值使用SMA
                            self.manual_indicators[key] = self.calculate_sma(period)
                        
                        alpha = 2.0 / (period + 1)
                        prev_ema = self.manual_indicators[key]
                        current_ema = alpha * self.data.close[0] + (1 - alpha) * prev_ema
                        self.manual_indicators[key] = current_ema
                        return current_ema
                    return 0.0
                except:
                    return 0.0
                    
            def calculate_rsi(self, period):
                """计算RSI"""
                try:
                    if len(self.data) >= period + 1:
                        gains = []
                        losses = []
                        for i in range(1, period + 1):
                            change = self.data.close[-i] - self.data.close[-i-1]
                            if change > 0:
                                gains.append(change)
                                losses.append(0)
                            else:
                                gains.append(0)
                                losses.append(abs(change))
                        
                        avg_gain = sum(gains) / len(gains)
                        avg_loss = sum(losses) / len(losses)
                        
                        if avg_loss == 0:
                            return 100.0
                        
                        rs = avg_gain / avg_loss
                        rsi = 100 - (100 / (1 + rs))
                        return rsi
                    return 50.0  # 中性值
                except:
                    return 50.0
                    
            def calculate_adx(self, period):
                """简化ADX计算"""
                return 25.0  # 返回中性值
                
            def calculate_macd(self, fast_period, slow_period, signal_period):
                """简化MACD计算"""
                try:
                    if len(self.data) >= max(fast_period, slow_period, signal_period):
                        fast_ema = self.calculate_ema(fast_period)
                        slow_ema = self.calculate_ema(slow_period)
                        macd_line = fast_ema - slow_ema
                        # 简化信号线计算
                        signal_line = macd_line * 0.9  # 简化处理
                        return {'macd': macd_line, 'signal': signal_line}
                    return {'macd': 0.0, 'signal': 0.0}
                except:
                    return {'macd': 0.0, 'signal': 0.0}
            
            def next(self):
                try:
                    # 计算最小周期
                    min_period = max(
                        strategy_config['params'].get('SMA', {}).get('period', 0),
                        strategy_config['params'].get('EMA', {}).get('period', 0),
                        strategy_config['params'].get('ADX', {}).get('period', 0),
                        strategy_config['params'].get('RSI', {}).get('period', 0),
                        strategy_config['params'].get('MACD', {}).get('period_me1', 0),
                        strategy_config['params'].get('MACD', {}).get('period_me2', 0),
                        strategy_config['params'].get('MACD', {}).get('period_signal', 0)
                    )
                    
                    if len(self.data) < min_period or self.warmup_period < min_period:
                        self.warmup_period += 1
                        return
                    
                    if len(self.broker.get_orders_open()) > 0:
                        return
                    
                    # 手动计算所有指标值
                    indicator_values = {}
                    indicator_values['close'] = float(self.data.close[0])
                    
                    # 计算基础指标
                    for indicator_name in strategy_config['indicators']:
                        params = strategy_config['params'].get(indicator_name, {})
                        
                        if indicator_name == 'SMA':
                            period = params.get('period', 20)
                            indicator_values[indicator_name] = self.calculate_sma(period)
                        elif indicator_name == 'EMA':
                            period = params.get('period', 20)
                            indicator_values[indicator_name] = self.calculate_ema(period)
                        elif indicator_name == 'RSI':
                            period = params.get('period', 14)
                            indicator_values[indicator_name] = self.calculate_rsi(period)
                        elif indicator_name == 'ADX':
                            period = params.get('period', 14)
                            indicator_values[indicator_name] = self.calculate_adx(period)
                        elif indicator_name == 'MACD':
                            fast_period = params.get('period_me1', 12)
                            slow_period = params.get('period_me2', 26)
                            signal_period = params.get('period_signal', 9)
                            macd_result = self.calculate_macd(fast_period, slow_period, signal_period)
                            indicator_values[indicator_name] = macd_result['macd']
                            indicator_values[f"{indicator_name}_SIGNAL"] = macd_result['signal']
                    
                    # 计算交叉信号
                    close_price = indicator_values['close']
                    for indicator_name in strategy_config['indicators']:
                        if indicator_name in indicator_values and indicator_name != 'MACD':
                            current_indicator_value = indicator_values[indicator_name]
                            crossover_name = f"CrossOver_{indicator_name}"
                            
                            prev_close = self.previous_values.get('close')
                            prev_indicator = self.previous_values.get(indicator_name)
                            
                            crossover_signal = self.calculate_manual_crossover(
                                close_price, current_indicator_value,
                                prev_close, prev_indicator
                            )
                            
                            indicator_values[crossover_name] = crossover_signal
                    
                    # MACD交叉信号
                    if 'MACD' in strategy_config['indicators']:
                        macd_value = indicator_values.get('MACD', 0.0)
                        macd_signal = indicator_values.get('MACD_SIGNAL', 0.0)
                        
                        prev_macd = self.previous_values.get('MACD')
                        prev_macd_signal = self.previous_values.get('MACD_SIGNAL')
                        
                        macd_crossover = self.calculate_manual_crossover(
                            macd_value, macd_signal,
                            prev_macd, prev_macd_signal
                        )
                        
                        indicator_values['CrossOver_MACD'] = macd_crossover
                    
                    # 更新前一个周期的值
                    self.previous_values['close'] = close_price
                    for indicator_name, value in indicator_values.items():
                        if not indicator_name.startswith('CrossOver'):
                            self.previous_values[indicator_name] = value
                    
                    # 获取交易规则
                    entry_rule = next((rule['expr'] for rule in strategy_config['rule'] if rule['type'] == 'entry'), None)
                    exit_rule = next((rule['expr'] for rule in strategy_config['rule'] if rule['type'] == 'exit'), None)
                    
                    # 执行交易逻辑
                    if not self.position:
                        if entry_rule:
                            try:
                                rule_result = eval(entry_rule, indicator_values)
                                if rule_result:
                                    logger.info("Entry signal triggered")
                                    self.buy()
                            except Exception as e:
                                logger.error(f"Error evaluating entry rule: {str(e)}")
                    else:
                        if exit_rule:
                            try:
                                rule_result = eval(exit_rule, indicator_values)
                                if rule_result:
                                    logger.info("Exit signal triggered")
                                    self.close()
                            except Exception as e:
                                logger.error(f"Error evaluating exit rule: {str(e)}")
                                
                except Exception as e:
                    logger.error(f"Error in next method: {str(e)}")
                    raise
        
        logger.info("Strategy class created")
        self.cerebro.addstrategy(Strategy)
        logger.info("Strategy added to backtest engine")

    def run_backtest(self) -> Dict[str, Any]:
        """
        Run backtest
        
        Returns:
            Dict[str, Any]: Backtest results
        """
        # Run backtest
        results = self.cerebro.run()
        
        # Get backtest results
        strat = results[0]
        
        # Calculate backtest metrics
        total_return = (self.cerebro.broker.getvalue() / INITIAL_CAPITAL) - 1
        
        # Calculate annualized return
        days = (strat.data.datetime.date(-1) - strat.data.datetime.date(0)).days
        annual_return = (1 + total_return) ** (365 / days) - 1
        
        # Calculate maximum drawdown
        drawdown = strat.analyzers.drawdown.get_analysis()
        max_dd_value = drawdown.get('max', {}).get('drawdown', 0.0)
        max_drawdown = float(max_dd_value) / 100 if hasattr(max_dd_value, '__float__') else 0.0
        
        # Calculate Sharpe ratio
        sharpe = strat.analyzers.sharpe.get_analysis()
        sharpe_ratio = float(sharpe.get('sharperatio', 0.0)) if hasattr(sharpe.get('sharperatio', 0.0), '__float__') else 0.0
        
        # Calculate win rate
        trades = strat.analyzers.trades.get_analysis()
        total_trades = int(trades.get('total', 0)) if hasattr(trades.get('total', 0), '__int__') else 0
        won_trades = int(trades.get('won', 0)) if hasattr(trades.get('won', 0), '__int__') else 0
        win_rate = won_trades / total_trades if total_trades > 0 else 0
        
        return {
            'strategy_name': self.strategy_config['name'],
            'total_return': total_return,
            'annual_return': annual_return,
            'max_drawdown': max_drawdown,
            'sharpe_ratio': sharpe_ratio,
            'win_rate': win_rate,
            'total_trades': total_trades,
            'trades': trades,
            'equity_curve': strat.analyzers.returns.get_analysis()
        }


def backtest_strategy(data: pd.DataFrame,
                       strategy: Dict[str, Any],
                       initial_capital: float = 100000.0) -> Dict[str, Any]:
    """
    Backtest a single trading strategy
    
    Args:
        data: Backtest data
        strategy: Strategy configuration dictionary
        initial_capital: Initial capital
        
    Returns:
        Dict[str, Any]: Backtest results
    """
    engine = BacktestEngine()
    logger.info(f"backtest engine set up successfully")
    engine.set_data(data)
    logger.info(f"backtest engine set data successfully")
    engine.add_strategy(strategy)
    logger.info(f"backtest engine added strategy successfully")
    return engine.run_backtest()

def evaluate_backtest(backtest_results: Dict[str, Any]) -> Dict[str, Any]:
    """
    Evaluate backtest results and generate detailed performance analysis report
    
    Args:
        backtest_results: Backtest results dictionary, containing strategy name, return, drawdown, etc.
        
    Returns:
        Dict[str, Any]: Dictionary containing detailed evaluation metrics
    """
    try:
        # 安全获取基础指标
        total_return = backtest_results.get('total_return', 0.0)
        annual_return = backtest_results.get('annual_return', 0.0)
        max_drawdown = backtest_results.get('max_drawdown', 0.0)
        sharpe_ratio = backtest_results.get('sharpe_ratio', 0.0)
        win_rate = backtest_results.get('win_rate', 0.0)
        total_trades = backtest_results.get('total_trades', 0)
        
        # Calculate risk-adjusted return metrics
        sortino_ratio = annual_return / (abs(max_drawdown) + 1e-6)  # Sortino ratio
        calmar_ratio = annual_return / (abs(max_drawdown) + 1e-6)   # Calmar ratio
        
        # 安全处理交易统计
        trades = backtest_results.get('trades', {})
        avg_trade_return = 0.0
        profit_factor = 1.0
        
        if isinstance(trades, dict) and 'pnl' in trades:
            try:
                pnl_data = trades['pnl']
                if isinstance(pnl_data, dict) and 'net' in pnl_data:
                    avg_trade_return = pnl_data['net'].get('average', 0.0)
                    total_pnl = pnl_data['net'].get('total', 0.0)
                    gross_pnl = pnl_data.get('gross', {}).get('total', 0.0)
                    if gross_pnl != 0:
                        profit_factor = abs(total_pnl) / abs(gross_pnl - total_pnl)
            except Exception as e:
                logger.warning(f"Could not extract trade PnL data: {str(e)}")
        
        # 安全处理资金曲线分析
        equity_curve = backtest_results.get('equity_curve', {})
        volatility = 0.0
        
        if isinstance(equity_curve, dict) and equity_curve:
            try:
                equity_values = list(equity_curve.values()) if equity_curve else [1.0]
                equity_series = pd.Series(equity_values)
                if len(equity_series) > 1:
                    volatility = equity_series.pct_change().std() * np.sqrt(252)
            except Exception as e:
                logger.warning(f"Could not calculate volatility: {str(e)}")
        
        # 安全计算连续亏损次数
        consecutive_losses = 0
        max_consecutive_losses = 0
        
        if isinstance(trades, dict) and 'trades' in trades:
            trade_list = trades.get('trades', [])
            if isinstance(trade_list, list):
                for trade in trade_list:
                    if isinstance(trade, dict) and trade.get('pnl', 0) < 0:
                        consecutive_losses += 1
                        max_consecutive_losses = max(max_consecutive_losses, consecutive_losses)
                    else:
                        consecutive_losses = 0
    
        # 安全计算风险指标
        var_95 = 0.0
        expected_shortfall = 0.0
        
        if isinstance(equity_curve, dict) and equity_curve:
            try:
                equity_values = list(equity_curve.values()) if equity_curve else [1.0]
                equity_series = pd.Series(equity_values)
                if len(equity_series) > 1:
                    returns = equity_series.pct_change().dropna()
                    if len(returns) > 0:
                        var_95 = returns.quantile(0.05)
                        tail_returns = returns[returns <= var_95]
                        if len(tail_returns) > 0:
                            expected_shortfall = tail_returns.mean()
            except Exception as e:
                logger.warning(f"Could not calculate risk metrics: {str(e)}")
        
        # Generate evaluation report
        evaluation_report = {
            'strategy_name': backtest_results.get('strategy_name', 'Unknown Strategy'),
            'performance_metrics': {
                'total_return': float(total_return),
                'annual_return': float(annual_return),
                'max_drawdown': float(max_drawdown),
                'sharpe_ratio': float(sharpe_ratio),
                'sortino_ratio': float(sortino_ratio),
                'calmar_ratio': float(calmar_ratio),
                'volatility': float(volatility)
            },
            'trading_statistics': {
                'total_trades': int(total_trades),
                'win_rate': float(win_rate),
                'profit_factor': float(profit_factor),
                'avg_trade_return': float(avg_trade_return),
                'max_consecutive_losses': int(max_consecutive_losses)
            },
            'risk_metrics': {
                'value_at_risk_95': float(var_95),
                'expected_shortfall': float(expected_shortfall)
            }
        }
        
        # Add evaluation conclusion
        overall_rating = 'Poor'  # 默认评级
        if sharpe_ratio > 1.5 and win_rate > 0.6 and abs(max_drawdown) < 0.2:
            overall_rating = 'Excellent'
        elif sharpe_ratio > 1.0 and win_rate > 0.5 and abs(max_drawdown) < 0.3:
            overall_rating = 'Good'
        elif sharpe_ratio > 0.5 and win_rate > 0.4 and abs(max_drawdown) < 0.4:
            overall_rating = 'Average'
            
        evaluation_report['conclusion'] = {
            'overall_rating': overall_rating,
            'strengths': [],
            'weaknesses': []
        }
        
        # Analyze strengths and weaknesses
        if sharpe_ratio > 1.0:
            evaluation_report['conclusion']['strengths'].append('风险调整收益表现优秀')
        if win_rate > 0.6:
            evaluation_report['conclusion']['strengths'].append('胜率较高')
        if abs(max_drawdown) < 0.2:
            evaluation_report['conclusion']['strengths'].append('回撤控制良好')
            
        if sharpe_ratio < 0.5:
            evaluation_report['conclusion']['weaknesses'].append('风险调整收益表现较差')
        if win_rate < 0.4:
            evaluation_report['conclusion']['weaknesses'].append('胜率偏低')
        if abs(max_drawdown) > 0.3:
            evaluation_report['conclusion']['weaknesses'].append('回撤过大')
        
        # Add is_satisfactory flag based on key metrics
        evaluation_report['is_satisfactory'] = bool(
            sharpe_ratio > 1.0 and
            win_rate > 0.5 and      
            abs(max_drawdown) < 0.3 and 
            total_trades >= 10      
        )
        
        logger.info(f"Backtest evaluation completed. Rating: {overall_rating}, Satisfactory: {evaluation_report['is_satisfactory']}")
        return evaluation_report
        
    except Exception as e:
        logger.error(f"Error in evaluate_backtest: {str(e)}", exc_info=True)
        
        # Return safe default evaluation results
        return {
            'strategy_name': backtest_results.get('strategy_name', 'Unknown Strategy'),
            'performance_metrics': {
                'total_return': 0.0,
                'annual_return': 0.0,
                'max_drawdown': 0.0,
                'sharpe_ratio': 0.0,
                'sortino_ratio': 0.0,
                'calmar_ratio': 0.0,
                'volatility': 0.0
            },
            'trading_statistics': {
                'total_trades': 0,
                'win_rate': 0.0,
                'profit_factor': 0.0,
                'avg_trade_return': 0.0,
                'max_consecutive_losses': 0
            },
            'risk_metrics': {
                'value_at_risk_95': 0.0,
                'expected_shortfall': 0.0
            },
            'conclusion': {
                'overall_rating': 'Error',
                'strengths': [],
                'weaknesses': ['评估过程中出现错误']
            },
            'is_satisfactory': False,
            'error': str(e)
        }

def quant_analysis(symbol: str, strategy: dict) -> dict:
    """
    Performs quantitative analysis based on the given symbol and trading strategy.
    It retrieves historical data, calculates indicators, generates real-time signals,
    runs backtesting, and returns a JSON report.
    """
    try:
        # 1. Get historical data
        historical_data = get_historical_data(symbol)
        if historical_data is None:
            raise ValueError(f"Failed to get historical data for asset {symbol}")
        logger.info(f"got historical_data")
            
        # 2. Calculate technical indicators
        data_with_indicators = calculate_indicators(historical_data)
        if data_with_indicators is None:
            raise ValueError("Failed to calculate technical indicators")
        logger.info(f"calculated indicators")
            
        # 3. Get real-time trading signal
        try:
            live_signal = generate_live_signal(data_with_indicators, strategy)
        except Exception as e:
            logger.warning(f"Failed to get real-time trading signal: {str(e)}")
            live_signal = "HOLD"  # Default hold
        logger.info(f"generated live signal: {live_signal}")
            
        # 4. Run backtest
        backtest_result = backtest_strategy(
            data=data_with_indicators,
            strategy=strategy,
            initial_capital=INITIAL_CAPITAL
        )
        logger.info(f"backtest result: {backtest_result}")
        # 5. Evaluate backtest results
        evaluation = evaluate_backtest(backtest_result)
        logger.info(f"evaluation result: {evaluation}")
        # 6. Generate backtest report
        report = {
            'status': 'success',
            'symbol': symbol,
            'strategy_name': strategy['name'],
            'backtest_period': {
                'start_date': historical_data.index[0].strftime('%Y-%m-%d'),
                'end_date': historical_data.index[-1].strftime('%Y-%m-%d')
            },
            'live_signal': live_signal,  # Add real-time trading signal
            'performance_metrics': evaluation['performance_metrics'],
            'trading_statistics': evaluation['trading_statistics'],
            'risk_metrics': evaluation['risk_metrics'],
            'conclusion': evaluation['conclusion'],
            'is_satisfactory': evaluation['is_satisfactory']  # Add strategy satisfaction flag
        }
        
        return report
        
    except Exception as e:
        logger.error(f"Failed to run quantitative trading backtest: {str(e)}")
        return {
            'status': 'error',
            'symbol': symbol,
            'error': str(e)
        }
    
def generate_live_signal(data: pd.DataFrame, strategy: Dict[str, Any]) -> str:
    """
    Generate live trading signal based on the latest data and strategy
    
    Args:
        data: DataFrame containing historical prices and technical indicators
        strategy: Strategy configuration dictionary
        
    Returns:
        str: The trading signal (BUY/SELL/HOLD)
    """
    try:
        # Get latest data
        latest_data = data.iloc[-1].copy()
        
        # 将Timestamp转换为字符串
        if isinstance(latest_data['datetime'], pd.Timestamp):
            latest_data['datetime'] = latest_data['datetime'].strftime('%Y-%m-%d %H:%M:%S')
        
        # 将numpy类型转换为Python原生类型
        latest_data_dict = {}
        for key, value in latest_data.items():
            if isinstance(value, (np.int64, np.float64)):
                latest_data_dict[key] = float(value)
            else:
                latest_data_dict[key] = value
        
        # Build prompt
        prompt = f"""
        You are an expert quant trader.
        Please determine whether to buy, sell, or hold based on the following data:
        
        Latest Market Data:
        {json.dumps(latest_data_dict, indent=2, ensure_ascii=False)}
        
        Trading Strategy:
        {json.dumps(strategy, indent=2, ensure_ascii=False)}
        
        Please only answer: BUY, SELL or HOLD
        """
        
        # Call LLM to get signal
        response = llm.invoke(prompt)
        # 获取 AIMessage 的内容
        signal = response.content.strip().upper()
        logger.info(f"generated live signal: {signal}")
        
        # Validate signal validity
        if signal not in ["BUY", "SELL", "HOLD"]:
            signal = "HOLD"  # Default hold
            
        return signal
        
    except Exception as e:
        logger.error(f"Error generating live signal: {str(e)}", exc_info=True)
        return "HOLD"  # Default to HOLD on error

# Initialize LLM and parser
llm = ChatOpenAI(model="gpt-4o", temperature=0.2)    
